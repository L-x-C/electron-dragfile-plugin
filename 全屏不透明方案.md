# 全屏不透明文件拖拽检测方案

## 方案概述

本方案采用 helper 进程 + 动态窗口管理的架构，实现了系统级文件拖拽事件检测。通过在鼠标按下时创建全屏检测窗口，在鼠标松开时销毁窗口，既保证了拖拽检测的准确性，又尽量减少对用户操作的影响。

## 技术架构

### 1. 核心组件

- **主进程 (lib.rs)**: 负责鼠标事件监听和动态窗口管理
- **Helper 进程 (drag-monitor-helper.rs)**: 独立的 winit 窗口进程，专门处理文件拖拽检测
- **进程间通信**: 通过 stdout/stdin 进行 JSON 格式的事件数据传输

### 2. 工作流程

```
用户操作 → 鼠标事件监听 → 动态创建/销毁窗口 → 文件拖拽检测 → 事件回调
```

1. **启动阶段**:
   - 启动鼠标事件监听
   - 注册文件拖拽事件回调
   - 配置 helper 进程路径

2. **检测阶段**:
   - `mousedown` → 创建全屏检测窗口
   - 文件拖拽 → 检测拖拽事件并输出 JSON
   - `mouseup` → 销毁检测窗口

3. **事件处理**:
   - Helper 进程输出 JSON 事件到 stdout
   - 主进程读取并解析事件
   - 转换为统一的事件格式并触发回调

## 关键配置

### 1. 窗口属性配置

```rust
let attributes = WindowAttributes::default()
    .with_title("File Drag Monitor Helper")
    .with_transparent(false) // 关键：不透明，确保能接收拖拽事件
    .with_decorations(false) // 无边框
    .with_window_level(WindowLevel::AlwaysOnTop) // 顶层窗口，确保接收事件
    .with_resizable(false)
    .with_enabled_buttons(WindowButtons::empty()) // 无窗口按钮
    .with_visible(true)
    .with_inner_size(PhysicalSize::new(monitor_size.width, monitor_size.height)) // 全屏尺寸
    .with_position(PhysicalPosition::new(0, 0)) // 覆盖整个屏幕
    .with_active(true); // 获得焦点，才能接收拖拽事件
```

### 2. 事件映射

| Helper 事件 | 主进程事件 | 说明 |
|-------------|------------|------|
| `hovered` | `hovered_file` | 文件悬停 |
| `dropped` | `dropped_file` | 文件放置 |
| `cancelled` | `hovered_file_cancelled` | 取消悬停 |

### 3. 动态窗口管理逻辑

```rust
fn handle_drag_window_management(mouse_event: &MouseEvent) {
    match mouse_event.event_type.as_str() {
        "mousedown" => {
            // 创建拖拽监控窗口
            if !drag_state.is_dragging {
                start_file_drag_monitor_internal(helper_path);
                drag_state.is_dragging = true;
            }
        }
        "mouseup" => {
            // 销毁拖拽监控窗口
            if drag_state.is_dragging {
                stop_file_drag_monitor_internal();
                drag_state.is_dragging = false;
            }
        }
        _ => {}
    }
}
```

## API 接口

### 1. 主函数

```javascript
const {
  startMouseMonitor,      // 启动鼠标监听
  stopMouseMonitor,       // 停止鼠标监听
  onMouseEvent,           // 注册鼠标事件回调
  removeMouseEventListener, // 移除鼠标事件回调
  isMonitoring,           // 检查鼠标监听状态
  startFileDragMonitor,   // 配置文件拖拽监控
  stopFileDragMonitor,    // 停止文件拖拽监控
  onFileDragEvent,        // 注册文件拖拽事件回调
  removeFileDragEventListener, // 移除文件拖拽事件回调
  isFileDragMonitoring    // 检查文件拖拽监控状态
} = require('./index');
```

### 2. 使用示例

```javascript
// 启动鼠标监听
await startMouseMonitor();

// 配置文件拖拽监控（传入 helper 路径）
const helperPath = path.join(__dirname, 'target', 'release', 'drag-monitor-helper');
await startFileDragMonitor(helperPath);

// 注册文件拖拽事件回调
const callbackId = await onFileDragEvent((err, event) => {
  console.log('文件拖拽事件:', event);
  // event.eventType: 'hovered_file' | 'dropped_file' | 'hovered_file_cancelled'
  // event.filePath: 文件路径
  // event.x, event.y: 坐标位置
});
```

## 编译和部署

### 1. 编译命令

```bash
# 编译主模块
npm run build

# 编译 helper 二进制文件
cargo build --release --bin drag-monitor-helper
```

### 2. 二进制文件位置

- **macOS**: `target/release/drag-monitor-helper`
- **Windows**: `target/release/drag-monitor-helper.exe`
- **Linux**: `target/release/drag-monitor-helper`

## 已知问题和限制

### 1. 系统兼容性

- **macOS**: 完全支持，但需要注意权限问题
- **Windows**: 理论支持，需要额外测试
- **Linux**: 理论支持，需要额外测试

### 2. 性能影响

- **内存使用**: 每次创建窗口约占用 10-20MB 内存
- **CPU 使用**: 窗口创建/销毁时有短暂的 CPU 峰值
- **系统影响**: 全屏窗口可能影响其他应用的视觉效果

### 3. 稳定性问题

**重要**: 全屏窗口在长时间使用后可能导致系统文件拖拽功能异常，表现为：
- 文件无法被拖拽
- 系统拖拽响应迟钝
- 需要执行以下命令恢复：

```bash
killall Dock
killall Finder
```

**缓解措施**:
- 避免长时间连续使用
- 在检测到异常时手动重启应用
- 考虑实现定期重启 helper 进程的机制

## 调试和故障排除

### 1. 日志输出

Helper 进程会输出详细的调试信息：

```
[helper] Starting drag monitor helper process (fast startup mode).
[helper] Event loop created successfully
[helper] Created semi-transparent full-screen window: 1920x1080 (ready for drag detection)
[helper] Semi-transparent window is ready and waiting for drag events
[helper] 🎯 File hovered: /path/to/file at (100.0, 200.0)
```

### 2. 常见问题

**问题 1**: 窗口不显示
- 检查 helper 二进制文件是否存在
- 确认系统权限设置
- 查看控制台错误信息

**问题 2**: 检测不到文件拖拽
- 确认窗口是不透明的 (`transparent: false`)
- 检查窗口是否获得了焦点 (`active: true`)
- 验证窗口层级设置 (`AlwaysOnTop`)

**问题 3**: 系统拖拽功能异常
- 执行 `killall Dock && killall Finder`
- 重启应用程序
- 检查是否有残留的 helper 进程

### 3. 测试脚本

使用项目中的测试脚本验证功能：

```bash
# 测试动态窗口管理
node test-dynamic-drag.js

# 测试文件拖拽检测
node test-file-drag.js
```

## 优化建议

### 1. 短期优化

- 实现窗口缓存机制，减少创建/销毁开销
- 添加错误恢复逻辑，自动重启异常的 helper 进程
- 优化窗口显示时机，减少视觉干扰

### 2. 长期优化

- 探索系统级 API 的可能性
- 研究更轻量级的检测方案
- 实现跨平台的统一接口

## 技术总结

本方案通过巧妙的架构设计，在 NAPI-RS 环境限制下实现了文件拖拽检测功能：

1. **进程分离**: 将 winit 窗口运行在独立进程中，避免了 NAPI 环境的 EventLoop 冲突
2. **动态管理**: 基于鼠标事件动态创建/销毁窗口，平衡了功能性和用户体验
3. **事件统一**: 通过 JSON 格式统一了不同平台的事件格式
4. **配置优化**: 通过大量测试找到了最稳定的窗口配置参数

虽然存在一些限制和已知问题，但本方案在当前技术条件下是可行的解决方案，为后续的优化和改进奠定了基础。